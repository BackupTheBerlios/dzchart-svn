unit Testu_dzListTemplateTest;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  Classes,
  TestFramework,
  u_dzQuicksort,
  u_dzListTest,
  u_dzSortedListTest;

type
  // Test methods for interface IMyItemList
  TestIMyItemList = class(TTestCase)
  strict private
    FIMyItemList: IMyItemList;
    FExpectedItemLeak: integer;
    function Compare(_Item1, _Item2: u_dzListTest.TMyItem): integer;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testInsert;
    procedure testExtract;
    procedure testDeleteAll;
    procedure testFreeAll;
    procedure testSort;
  end;

  // Test methods for class TMyItemList
  TestTMyItemList = class(TTestCase)
  strict private
    FMyItemList: TMyItemList;
    FExpectedItemLeak: integer;
    function Compare(_Item1, _Item2: u_dzListTest.TMyItem): integer;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testInsert;
    procedure testExtract;
    procedure testDeleteAll;
    procedure testFreeAll;
    procedure testSort;
  end;

  // Test methods for class TMySortedList
  TestTMySortedList = class(TTestCase)
  strict private
    FMySortedList: TMySortedList;
    FExpectedItemLeak: integer;
  private
    procedure Fill;
    procedure InsertDupError;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testInsert;
    procedure testInsertDupError;
    procedure testInsertDupIgnore;
    procedure testInsertDupAccept;
    procedure testDeleteAll;
    procedure testExtract;
    procedure testFreeAll;
    procedure testSearchIdx;
    procedure testSearchItem;
  end;

implementation

const
  INSERT_COUNT = 11;

var
  ItemCount: integer = 0;

type
  TMyItem = class(u_dzListTest.TMyItem)
  public
    constructor Create(_Id: integer);
    destructor Destroy; override;
  end;

{ TMyItem }

constructor TMyItem.Create(_Id: integer);
begin
  inherited Create(_Id);
  Inc(ItemCount);
end;

destructor TMyItem.Destroy;
begin
  Dec(ItemCount);
  inherited;
end;

{ TestIMyItemList }

procedure TestIMyItemList.SetUp;
begin
  FIMyItemList := TMyItemList.Create;
  ItemCount := 0;
  FExpectedItemLeak := 0;
end;

procedure TestIMyItemList.TearDown;
begin
  FIMyItemList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestIMyItemList.testExtract;
var
  i: integer;
  Item: u_dzListTest.TMyItem;
begin
  testInsert;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FIMyItemList.Extract(0);
    CheckEquals(i, Item.Id, 'Id does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item.Free;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FIMyItemList.Count, 'List is not empty');
end;

procedure TestIMyItemList.testDeleteAll;
begin
  testInsert;
  FIMyItemList.DeleteAll;
  CheckEquals(0, FIMyItemList.Count, 'List is not empty');
  CheckEquals(INSERT_COUNT, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := INSERT_COUNT;
end;

procedure TestIMyItemList.testFreeAll;
begin
  testInsert;
  FIMyItemList.FreeAll;
  CheckEquals(0, FIMyItemList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestIMyItemList.testInsert;
var
  i: integer;
  Item: u_dzListTest.TMyItem;
begin
  for i := 0 to INSERT_COUNT - 1 do begin
    FIMyItemList.Insert(TMyItem.Create(i));
  end;
  CheckEquals(INSERT_COUNT, FIMyItemList.Count, 'Count does not match');
  CheckEquals(INSERT_COUNT, ItemCount, 'Number of created items does not match');

  for i := 0 to FIMyItemList.Count - 1 do begin
    Item := FIMyItemList.Items[i];
    CheckEquals(i, Item.Id, 'Id does not match');
  end;
end;

function TestIMyItemList.Compare(_Item1, _Item2: u_dzListTest.TMyItem): integer;
begin
  Result := _Item2.Id - _Item1.Id;
end;

procedure TestIMyItemList.testSort;
var
  i: integer;
begin
  testInsert;

  FIMyItemList.Sort(Compare);
  for i := 0 to FIMyItemList.Count - 1 do begin
    CheckEquals(INSERT_COUNT - 1 - i, FIMyItemList.Items[i].Id);
  end;
end;

{ TestTMyItemList }

procedure TestTMyItemList.SetUp;
begin
  FMyItemList := TMyItemList.Create;
  ItemCount := 0;
end;

procedure TestTMyItemList.TearDown;
begin
  FMyItemList.Free;
  FMyItemList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemList.testExtract;
var
  i: integer;
  Item: u_dzListTest.TMyItem;
begin
  testInsert;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FMyItemList.Extract(0);
    CheckEquals(i, Item.Id, 'Id does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item.Free;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FMyItemList.Count, 'List is not empty');
end;

procedure TestTMyItemList.testDeleteAll;
begin
  testInsert;
  FMyItemList.DeleteAll;
  CheckEquals(0, FMyItemList.Count, 'List is not empty');
  CheckEquals(INSERT_COUNT, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := INSERT_COUNT;
end;

procedure TestTMyItemList.testFreeAll;
begin
  testInsert;
  FMyItemList.FreeAll;
  CheckEquals(0, FMyItemList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemList.testInsert;
var
  i: integer;
  Item: u_dzListTest.TMyItem;
begin
  for i := 0 to INSERT_COUNT - 1 do begin
    FMyItemList.Insert(TMyItem.Create(i));
  end;
  CheckEquals(INSERT_COUNT, FMyItemList.Count, 'Count does not match');
  CheckEquals(INSERT_COUNT, ItemCount, 'Number of created items does not match');

  for i := 0 to FMyItemList.Count - 1 do begin
    Item := FMyItemList.Items[i];
    CheckEquals(i, Item.Id, 'Id does not match');
  end;
end;

function TestTMyItemList.Compare(_Item1, _Item2: u_dzListTest.TMyItem): integer;
begin
  Result := _Item2.Id - _Item1.Id;
end;

procedure TestTMyItemList.testSort;
var
  i: integer;
begin
  testInsert;

  FMyItemList.Sort(Compare);
  for i := 0 to FMyItemList.Count - 1 do begin
    CheckEquals(INSERT_COUNT - 1 - i, FMyItemList.Items[i].Id);
  end;
end;

{ TestTMySortedList }

procedure TestTMySortedList.SetUp;
begin
  FMySortedList := TMySortedList.Create;
  ItemCount := 0;
end;

procedure TestTMySortedList.TearDown;
begin
  FMySortedList.Free;
  FMySortedList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestTMySortedList.Fill;
var
  i: integer;
begin
  for i := INSERT_COUNT - 1 downto 0 do begin
    FMySortedList.Insert(TMyItem.Create(i));
  end;
end;

procedure TestTMySortedList.testDeleteAll;
begin
  Fill;
  FMySortedList.DeleteAll;
  CheckEquals(0, FMySortedList.Count, 'List is not empty');
  CheckEquals(INSERT_COUNT, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := INSERT_COUNT;
end;

procedure TestTMySortedList.testExtract;
var
  i: integer;
  Item: u_dzListTest.TMyItem;
begin
  Fill;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FMySortedList.Extract(0);
    CheckEquals(i, Item.Id, 'Id does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item.Free;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FMySortedList.Count, 'List is not empty');
end;

procedure TestTMySortedList.testFreeAll;
begin
  Fill;
  FMySortedList.FreeAll;
  CheckEquals(0, FMySortedList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMySortedList.testInsert;
var
  i: integer;
  Item: u_dzListTest.TMyItem;
begin
  Fill;

  Assert(FMySortedList.Count = INSERT_COUNT);

  for i := 0 to FMySortedList.Count - 1 do begin
    Item := FMySortedList.Items[i];
    CheckEquals(i, Item.Id, 'Id does not match');
  end;
end;

procedure TestTMySortedList.testInsertDupAccept;
begin
  FMySortedList.Duplicates := dupAccept;
  Fill;

  FMySortedList.Insert(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT + 1, FMySortedList.Count, 'Count does not match');

  CheckEquals(INSERT_COUNT + 1, ItemCount, 'Number of created items does not match');
end;

procedure TestTMySortedList.InsertDupError;
begin
  FMySortedList.Insert(TMyItem.Create(5));
end;

procedure TestTMySortedList.testInsertDupError;
begin
  Fill;

  CheckException(InsertDupError, EListError, 'expected exception did not occur');

  FExpectedItemLeak := 1;
end;

procedure TestTMySortedList.testInsertDupIgnore;
begin
  FMySortedList.Duplicates := dupIgnore;
  Fill;

  FMySortedList.Insert(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT, FMySortedList.Count, 'Count does not match');

  CheckEquals(INSERT_COUNT + 1, ItemCount, 'Number of created items does not match');

  FExpectedItemLeak := 1;
end;

procedure TestTMySortedList.testSearchIdx;
var
  Idx: integer;
begin
  Fill;

  CheckTrue(FMySortedList.Search(5, Idx), 'item not found');
  CheckEquals(5, Idx, 'Item does not have expected index');
end;

procedure TestTMySortedList.testSearchItem;
var
  Item: u_dzListTest.TMyItem;
begin
  Fill;

  CheckTrue(FMySortedList.Search(5, Item), 'item not found');
  CheckEquals(5, Item.Id, 'Item does not have expected Id');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestIMyItemList.Suite);
  RegisterTest(TestTMyItemList.Suite);
  RegisterTest(TestTMySortedList.Suite);
end.

