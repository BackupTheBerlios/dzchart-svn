// This script sorts the methods and properties in the selected region by name
// keeping the groups together (methods go first, followed by properties).
//
// Example:
//
//  function World;
//  property Trallala: string read GetTrallala write SetTrallala;
//  procedure Hello;
//
// will be changed to
//
//  procedure Hello;
//  function World;
//  property Trallala: string read GetTrallala write SetTrallala;
//
// Note: This currently does not work if a declaration spans multiple lines
//       or if there are comments.

function IsTokenChar(strChar: String): boolean;
var
  ascPosition: integer;
begin
  ascPosition := Ord(strChar);
  if ((ascPosition >= 48) and (ascPosition <= 57)) or
     ((ascPosition >= 65) and (ascPosition <= 90)) or
     ((ascPosition >= 97) and (ascPosition <= 122)) then
    Result := True
  else
    Result := False;
end;

function ExtractFirstToken(var _Text: string): string;
var
  CharFound: boolean;
  TheChar: string;
begin
  _Text := Trim(_Text);
  Result := '';
  CharFound := False;
  while _Text <> '' do begin
    TheChar := Copy(_Text, 1, 1);
    if IsTokenChar(TheChar) then begin
      CharFound := True;
      Result := Result + TheChar;
      Delete(_Text, 1, 1);
    end else if CharFound then
      Exit;
  end;
end;

type
  TDeclaration = class
    FContent: string;
    FName: string;
    FType: string;
    constructor Create(const _Type, _Name, _Content: string);
    function GetKey: string;
  end;

constructor TDeclaration.Create(const _Type, _Name, _Content: string);
begin
  inherited Create;
  FType := _Type;
  FName := _Name;
  FContent := _Content;
end;

function TDeclaration.GetKey: string;
begin
  if AnsiCompareText(FType, 'property') = 0 then
    Result := '2'
  else
    Result := '1';
  Result := Result + FName;
end;

var Content: string;
Content := TIdeEditor.GetSelectedText;
if Content = '' then
  exit;

var Selection: TStringList;
Selection := TStringList.Create;
Selection.Text := Content;

var Declarations: TStringHashTable;
var DeclNames: TStringList;
DeclNames := TStringList.Create;
DeclNames.Sorted := true;
Declarations := TStringHashTable.Create;

var i: integer;
var TypeStr: string;
var Name: string;
var Line: string;
var Declaration: TDeclaration;
for i := 0 to Selection.Count - 1 do begin
  Line := Selection[i];
  TypeStr := ExtractFirstToken(Line);
  Name := ExtractFirstToken(Line);
  Declaration := TDeclaration.Create(TypeStr, Name, Selection[i]);
  DeclNames.Add(Declaration.GetKey);
  Declarations.Put(Declaration.GetKey, Declaration);
end;

Selection.Clear;
for i := 0 to DeclNames.Count - 1 do begin
  Declaration := Declarations.Get(DeclNames[i]) as TDeclaration;
  Selection.Add(Declaration.FContent);
end;

TIdeEditor.SetSelectedText(Selection.Text);
{
type
  TSomething = class
  public
    function Welt;
    property Trallala: string read GetTrallala write SetTrallala;
    procedure Hallo;
  end;
}
